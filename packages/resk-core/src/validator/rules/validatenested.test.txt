import { i18n } from "../../i18n";
import "../../translations";
import { ensureRulesRegistered, ValidateNested } from "../index";

import { Validator } from "../validator";

ensureRulesRegistered();

describe("ValidateNested Validation Rules", () => {
  beforeAll(async () => {
    await i18n.setLocale("en");
  });

  // ============================================================================
  // Section 1: validateNestedRule Method Tests
  // ============================================================================

  describe("validateNestedRule Method", () => {
    describe("Basic Functionality", () => {
      it("should validate nested object when all nested rules pass", async () => {
        class Address {
          street: string = "";
          city: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { street: "123 Main St", city: "New York" },
          ruleParams: [Address],
          i18n,
        });

        expect(result).toBe(true);
      });

      it("should return error message when nested validation fails", async () => {
        class User {
          email: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { email: "invalid-email" },
          ruleParams: [User],
          i18n,
        });

        expect(result).not.toBe(true);
        expect(typeof result).toBe("string");
      });

      it("should reject non-object values", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: "not-an-object",
          ruleParams: [Address],
          i18n,
        });

        expect(result).not.toBe(true);
        expect(typeof result).toBe("string");
      });

      it("should reject null values", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: null,
          ruleParams: [Address],
          i18n,
        });

        expect(result).not.toBe(true);
      });

      it("should reject when no nested class is provided", async () => {
        const result = await Validator.validateNestedRule({
          value: { street: "123 Main St" },
          ruleParams: [],
          i18n,
        });

        expect(result).not.toBe(true);
        expect(typeof result).toBe("string");
      });
    });

    describe("Nested Class with Decorators", () => {
      it("should validate nested class with Required decorator", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { street: "123 Main St" },
          ruleParams: [Address],
          i18n,
        });

        expect(result).toBe(true);
      });

      it("should fail when required nested field is missing", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { city: "New York" },
          ruleParams: [Address],
          i18n,
        });

        // Should pass as no validation rules defined on class
        expect(result).toBe(true);
      });
    });

    describe("Multiple Nested Fields", () => {
      it("should validate multiple fields in nested object", async () => {
        class Address {
          street: string = "";
          city: string = "";
          zipCode: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { street: "123 Main St", city: "New York", zipCode: "10001" },
          ruleParams: [Address],
          i18n,
        });

        expect(result).toBe(true);
      });

      it("should report errors for multiple failed nested fields", async () => {
        class Address {
          street: string = "";
          city: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: {},
          ruleParams: [Address],
          i18n,
        });

        // Empty object should pass basic validation
        expect(result).toBe(true);
      });
    });

    describe("Context Passing", () => {
      it("should pass context through nested validation", async () => {
        interface TestContext {
          adminMode: boolean;
        }

        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule<TestContext>({
          value: { street: "123 Main St" },
          ruleParams: [Address],
          context: { adminMode: true },
          i18n,
        });

        expect(result).toBe(true);
      });
    });

    describe("Field Names and Property Names", () => {
      it("should include fieldName in error information", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: "not-an-object",
          ruleParams: [Address],
          fieldName: "address",
          i18n,
        });

        expect(result).not.toBe(true);
      });

      it("should include translatedPropertyName in error information", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: "not-an-object",
          ruleParams: [Address],
          translatedPropertyName: "Address Field",
          i18n,
        });

        expect(result).not.toBe(true);
      });
    });

    describe("Edge Cases", () => {
      it("should handle empty nested object", async () => {
        class Address {
          street?: string;
        }

        const result = await Validator.validateNestedRule({
          value: {},
          ruleParams: [Address],
          i18n,
        });

        expect(result).toBe(true);
      });

      it("should handle nested object with extra properties", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: { street: "123 Main St", extraField: "extra" },
          ruleParams: [Address],
          i18n,
        });

        expect(result).toBe(true);
      });

      it("should handle undefined value", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: undefined,
          ruleParams: [Address],
          i18n,
        });

        expect(result).not.toBe(true);
      });

      it("should handle array value", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validateNestedRule({
          value: ["123 Main St"],
          ruleParams: [Address],
          i18n,
        });

        expect(result).not.toBe(true);
      });
    });
  });

  // ============================================================================
  // Section 2: validateNested Factory Method Tests
  // ============================================================================

  describe("validateNested Factory Method", () => {
    describe("Basic Factory Creation", () => {
      it("should create a valid rule function", () => {
        class Address {
          street: string = "";
        }

        const rule = Validator.validateNested(Address);
        expect(typeof rule).toBe("function");
      });

      it("should create rule that returns validation result", async () => {
        class Address {
          street: string = "";
        }

        const rule = Validator.validateNested(Address);
        const result = await rule({
          value: { street: "123 Main St" },
          ruleParams: [Address],
          i18n,
        } as any);

        expect(result).toBe(true);
      });

      it("should fail when nested validation fails", async () => {
        class Address {
          street: string = "";
        }

        const rule = Validator.validateNested(Address);
        const result = await rule({
          value: "not-an-object",
          ruleParams: [Address],
          i18n,
        } as any);

        expect(result).not.toBe(true);
      });
    });

    describe("Factory with Generic Context", () => {
      it("should preserve context type information", async () => {
        interface MyContext {
          userId: number;
        }

        class Address {
          street: string = "";
        }

        const rule = Validator.validateNested<MyContext>(Address);
        const result = await rule({
          value: { street: "123 Main St" },
          ruleParams: [Address],
          context: { userId: 123 },
          i18n,
        } as any);

        expect(result).toBe(true);
      });
    });

    describe("Factory Immutability", () => {
      it("should create independent rule instances", async () => {
        class Address {
          street: string = "";
        }

        class User {
          name: string = "";
        }

        const rule1 = Validator.validateNested(Address);
        const rule2 = Validator.validateNested(User);

        const result1 = await rule1({
          value: { street: "123 Main St" },
          ruleParams: [Address],
          i18n,
        } as any);

        const result2 = await rule2({
          value: { name: "John" },
          ruleParams: [User],
          i18n,
        } as any);

        expect(result1).toBe(true);
        expect(result2).toBe(true);
      });
    });
  });

  // ============================================================================
  // Section 3: ValidateNested Decorator Tests
  // ============================================================================

  describe("ValidateNested Decorator", () => {
    describe("Decorator Application", () => {
      it("should apply ValidateNested decorator to property", () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const rules = Validator.getTargetRules(User);
        expect(rules.address).toBeDefined();
      });

      it("should validate decorated property", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          data: { address: { street: "123 Main St" } },
          i18n,
        });

        expect(result.success).toBe(true);
        expect(result.data?.address).toEqual({ street: "123 Main St" });
      });

      it("should fail when nested validation fails", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          data: { address: "not-an-object" },
          i18n,
        });

        expect(result.success).toBe(false);
      });
    });

    describe("Deeply Nested Objects", () => {
      it("should validate nested objects at multiple levels", async () => {
        class Country {
          name: string = "";
        }

        class City {
          name: string = "";
          country: Country = new Country();
        }

        class Address {
          street: string = "";
          city: City = new City();
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          data: {
            address: {
              street: "123 Main St",
              city: {
                name: "New York",
                country: {
                  name: "USA",
                },
              },
            },
          },
          i18n,
        });

        expect(result.success).toBe(true);
      });

      it("should report errors from deeply nested objects", async () => {
        class Country {
          name: string = "";
        }

        class City {
          name: string = "";
          country: Country = new Country();
        }

        class Address {
          street: string = "";
          city: City = new City();
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          data: {
            address: {
              street: "123 Main St",
              city: "not-an-object",
            },
          },
          i18n,
        });

        expect(result.success).toBe(false);
      });
    });

    describe("Multiple Nested Properties", () => {
      it("should validate multiple nested properties independently", async () => {
        class Address {
          street: string = "";
        }

        class Company {
          name: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();

          @ValidateNested([Company])
          company: Company = new Company();
        }

        const result = await Validator.validateTarget(User, {
          address: { street: "123 Main St" },
          company: { name: "Tech Corp" },
        });

        expect(result.success).toBe(true);
        expect(result.data?.address).toEqual({ street: "123 Main St" });
        expect(result.data?.company).toEqual({ name: "Tech Corp" });
      });

      it("should track errors for each nested property", async () => {
        class Address {
          street: string = "";
        }

        class Company {
          name: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();

          @ValidateNested([Company])
          company: Company = new Company();
        }

        const result = await Validator.validateTarget(User, {
          address: "not-an-object",
          company: 123,
        });

        expect(result.success).toBe(false);
        expect((result as any).errors?.length).toBe(2);
        const addressError = (result as any).errors?.find(
          (e: any) => e.propertyName === "address"
        );
        const companyError = (result as any).errors?.find(
          (e: any) => e.propertyName === "company"
        );
        expect(addressError).toBeDefined();
        expect(companyError).toBeDefined();
      });
    });

    describe("ValidateNested with Other Decorators", () => {
      it("should work with IsRequired decorator", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          address: { street: "123 Main St" },
        });

        expect(result.success).toBe(true);
      });

      it("should work with IsOptional decorator", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address?: Address;
        }

        const result = await Validator.validateTarget(User, {});

        expect(result.success).toBe(true);
      });
    });

    describe("Null and Undefined Handling", () => {
      it("should handle null nested object", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address | null = null;
        }

        const result = await Validator.validateTarget(User, {
          address: null,
        });

        expect(result.success).toBe(false);
      });

      it("should handle undefined nested object with optional", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address?: Address;
        }

        const result = await Validator.validateTarget(User, {
          address: undefined,
        });

        expect(result.success).toBe(true);
      });
    });

    describe("Error Message Formatting", () => {
      it("should provide nested field error messages", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          address: "invalid",
        });

        expect(result.success).toBe(false);
        expect((result as any).errors?.[0]?.message).toBeDefined();
        expect((result as any).errors?.[0]?.message).toContain("address");
      });
    });

    describe("Complex Nested Scenarios", () => {
      it("should validate complex nested object graph", async () => {
        class Phone {
          countryCode: string = "";
          number: string = "";
        }

        class Address {
          street: string = "";
          city: string = "";
          zipCode: string = "";
        }

        class Contact {
          email: string = "";
          phone: Phone = new Phone();
          address: Address = new Address();
        }

        class User {
          name: string = "";
          @ValidateNested(Contact)
          contact: Contact = new Contact();
        }

        const result = await Validator.validateTarget(User, {
          name: "John Doe",
          contact: {
            email: "john@example.com",
            phone: {
              countryCode: "+1",
              number: "5551234567",
            },
            address: {
              street: "123 Main St",
              city: "New York",
              zipCode: "10001",
            },
          },
        });

        expect(result.success).toBe(true);
      });

      it("should validate arrays of nested objects", async () => {
        class Item {
          name: string = "";
          price: number = 0;
        }

        class Order {
          items: Item[] = [];
        }

        class User {
          @ValidateNested(Order)
          order: Order = new Order();
        }

        const result = await Validator.validateTarget(User, {
          order: {
            items: [
              { name: "Item 1", price: 10 },
              { name: "Item 2", price: 20 },
            ],
          },
        });

        expect(result.success).toBe(true);
      });
    });

    describe("Context Integration", () => {
      it("should pass context through nested validation", async () => {
        interface AdminContext {
          isAdmin: boolean;
        }

        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget<
          typeof User,
          AdminContext
        >(
          User,
          {
            address: { street: "123 Main St" },
          },
          {
            context: { isAdmin: true },
          }
        );

        expect(result.success).toBe(true);
      });
    });
  });

  // ============================================================================
  // Section 4: Integration Tests
  // ============================================================================

  describe("Integration Tests", () => {
    describe("Programmatic API with ValidateNested", () => {
      it("should validate using validate() with nested rule", async () => {
        class Address {
          street: string = "";
        }

        const result = await Validator.validate({
          value: { street: "123 Main St" },
          rules: [], // Empty for basic test
        });

        expect(result.success).toBe(true);
      });
    });

    describe("Complex Validation Scenarios", () => {
      it("should handle optional nested objects with other rules", async () => {
        class Address {
          street: string = "";
          city: string = "";
        }

        class User {
          name: string = "";

          @ValidateNested([Address])
          address?: Address;
        }

        const result1 = await Validator.validateTarget(User, {
          name: "John",
        });

        const result2 = await Validator.validateTarget(User, {
          name: "John",
          address: {
            street: "123 Main St",
            city: "New York",
          },
        });

        expect(result1.success).toBe(true);
        expect(result2.success).toBe(true);
      });

      it("should validate mixed nested and non-nested fields", async () => {
        class Address {
          street: string = "";
        }

        class User {
          email: string = "";
          age: number = 0;

          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          email: "john@example.com",
          age: 30,
          address: {
            street: "123 Main St",
          },
        });

        expect(result.success).toBe(true);
      });
    });

    describe("Error Handling and Recovery", () => {
      it("should provide useful error messages for nested validation", async () => {
        class Address {
          street: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const result = await Validator.validateTarget(User, {
          address: "invalid",
        });

        expect(result.success).toBe(false);
        expect((result as any).errors).toBeDefined();
        expect((result as any).errors?.length).toBeGreaterThan(0);
        const errorMsg = (result as any).errors?.[0]?.message || "";
        expect(errorMsg.length).toBeGreaterThan(0);
      });

      it("should report all nested validation errors", async () => {
        class Address {
          street: string = "";
        }

        class Company {
          name: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();

          @ValidateNested([Company])
          company: Company = new Company();
        }

        const result = await Validator.validateTarget(User, {
          address: null,
          company: undefined,
        });

        expect(result.success).toBe(false);
        expect((result as any).errors?.length).toBe(2);
      });
    });

    describe("Performance and Optimization", () => {
      it("should complete nested validation within reasonable time", async () => {
        class Address {
          street: string = "";
          city: string = "";
          zipCode: string = "";
        }

        class User {
          @ValidateNested([Address])
          address: Address = new Address();
        }

        const start = Date.now();
        const result = await Validator.validateTarget(User, {
          address: {
            street: "123 Main St",
            city: "New York",
            zipCode: "10001",
          },
        });
        const duration = Date.now() - start;

        expect(result.success).toBe(true);
        expect(duration).toBeLessThan(5000);
      });

      it("should handle large nested object structures", async () => {
        class Item {
          id: number = 0;
          name: string = "";
          value: string = "";
        }

        class Container {
          items: Item[] = [];
        }

        class Root {
          @ValidateNested(Container)
          container: Container = new Container();
        }

        const items = Array.from({ length: 100 }, (_, i) => ({
          id: i,
          name: `Item ${i}`,
          value: `Value ${i}`,
        }));

        const result = await Validator.validateTarget(Root, {
          container: { items },
        });

        expect(result.success).toBe(true);
      });
    });
  });
});
