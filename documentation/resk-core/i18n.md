# üåê Internationalization (i18n) - @resk/core/i18n

> **Comprehensive multi-language support with reactive capabilities**

## üìñ Overview

The I18n module extends the powerful i18n-js library with observable capabilities, providing a complete internationalization solution for your applications. It supports dynamic language switching, pluralization, interpolation, and real-time translation updates.

---

## üöÄ Quick Start

### **Basic Setup**

```typescript
import { I18n } from '@resk/core/i18n';

// Configure translations
I18n.configure({
  locale: 'en',
  fallbacks: true,
  translations: {
    en: {
      welcome: 'Welcome',
      greeting: 'Hello %{name}!',
      items: {
        zero: 'No items',
        one: 'One item',
        other: '%{count} items'
      }
    },
    fr: {
      welcome: 'Bienvenue',
      greeting: 'Bonjour %{name}!',
      items: {
        zero: 'Aucun √©l√©ment',
        one: 'Un √©l√©ment',
        other: '%{count} √©l√©ments'
      }
    },
    es: {
      welcome: 'Bienvenido',
      greeting: '¬°Hola %{name}!',
      items: {
        zero: 'Sin elementos',
        one: 'Un elemento',
        other: '%{count} elementos'
      }
    }
  }
});

// Use translations
console.log(I18n.t('welcome'));              // "Welcome"
console.log(I18n.t('greeting', { name: 'John' })); // "Hello John!"
console.log(I18n.t('items', { count: 0 }));  // "No items"
console.log(I18n.t('items', { count: 5 }));  // "5 items"
```

---

## üé≠ Translation Decorators

### **@Translate Decorator**

```typescript
import { Translate } from '@resk/core/i18n';

class UserInterface {
  // Automatic translation binding
  @Translate('user.welcome')
  welcomeMessage: string;
  
  @Translate('user.profile.title')
  profileTitle: string;
  
  @Translate('buttons.save')
  saveButtonText: string;
  
  // Method translations
  @Translate('user.actions.delete')
  getDeleteConfirmation(): string {
    return ''; // Will be replaced with translation
  }
}

// Usage
const ui = new UserInterface();
console.log(ui.welcomeMessage);    // Automatically translated
console.log(ui.profileTitle);      // Automatically translated
```

### **Dynamic Translation Properties**

```typescript
class ProductCatalog {
  @Translate('product.name')
  productName: string;
  
  @Translate('product.description')
  productDescription: string;
  
  // Context-aware translations
  @Translate('product.status.available')
  availableStatus: string;
  
  @Translate('product.status.outOfStock')
  outOfStockStatus: string;
  
  getStatusText(inStock: boolean): string {
    return inStock ? this.availableStatus : this.outOfStockStatus;
  }
}
```

---

## üîß Advanced Translation Features

### **Interpolation and Variables**

```typescript
// Translation definitions
const translations = {
  en: {
    user: {
      profile: 'Profile of %{userName}',
      lastLogin: 'Last login: %{date} at %{time}',
      stats: 'You have %{posts} posts and %{comments} comments',
      welcome: 'Welcome back, %{name}! You have %{unread} unread messages.'
    }
  }
};

// Usage with interpolation
I18n.t('user.profile', { userName: 'John Doe' });
// Result: "Profile of John Doe"

I18n.t('user.lastLogin', { 
  date: '2024-01-15', 
  time: '14:30' 
});
// Result: "Last login: 2024-01-15 at 14:30"

I18n.t('user.stats', { 
  posts: 42, 
  comments: 128 
});
// Result: "You have 42 posts and 128 comments"
```

### **Pluralization Rules**

```typescript
const translations = {
  en: {
    notifications: {
      zero: 'No new notifications',
      one: 'You have one new notification',
      other: 'You have %{count} new notifications'
    },
    files: {
      zero: 'No files selected',
      one: 'One file selected',
      other: '%{count} files selected'
    },
    time: {
      minutes: {
        zero: 'Less than a minute',
        one: 'About a minute',
        other: 'About %{count} minutes'
      }
    }
  },
  fr: {
    notifications: {
      zero: 'Aucune nouvelle notification',
      one: 'Vous avez une nouvelle notification',
      other: 'Vous avez %{count} nouvelles notifications'
    }
  }
};

// Usage
I18n.t('notifications', { count: 0 });   // "No new notifications"
I18n.t('notifications', { count: 1 });   // "You have one new notification"
I18n.t('notifications', { count: 5 });   // "You have 5 new notifications"

// French pluralization
I18n.locale = 'fr';
I18n.t('notifications', { count: 0 });   // "Aucune nouvelle notification"
```

---

## üéØ Observable Translation System

### **Real-time Language Switching**

```typescript
import { I18n } from '@resk/core/i18n';

class MultiLanguageComponent {
  private currentTexts: any = {};
  
  constructor() {
    // Subscribe to locale changes
    I18n.observe('localeChanged', (newLocale) => {
      this.updateTranslations();
      console.log('Language switched to:', newLocale);
    });
    
    // Subscribe to translation updates
    I18n.observe('translationsUpdated', (translations) => {
      this.updateTranslations();
      console.log('Translations updated');
    });
    
    this.updateTranslations();
  }
  
  private updateTranslations() {
    this.currentTexts = {
      title: I18n.t('app.title'),
      welcome: I18n.t('app.welcome'),
      navigation: {
        home: I18n.t('nav.home'),
        about: I18n.t('nav.about'),
        contact: I18n.t('nav.contact')
      }
    };
    
    // Update UI
    this.renderUI();
  }
  
  private renderUI() {
    // Update DOM or component state with new translations
    console.log('Updated translations:', this.currentTexts);
  }
  
  switchLanguage(newLocale: string) {
    I18n.locale = newLocale; // Automatically triggers observers
  }
}

// Usage
const component = new MultiLanguageComponent();
component.switchLanguage('fr'); // Automatically updates all translations
component.switchLanguage('es'); // Automatically updates all translations
```

### **Translation Loading Events**

```typescript
class TranslationManager {
  constructor() {
    // Monitor translation loading
    I18n.observe('translationsLoading', (locale) => {
      this.showLoadingIndicator();
      console.log('Loading translations for:', locale);
    });
    
    I18n.observe('translationsLoaded', (locale, translations) => {
      this.hideLoadingIndicator();
      console.log('Translations loaded for:', locale);
    });
    
    I18n.observe('translationsError', (locale, error) => {
      this.showError(error);
      console.error('Failed to load translations for:', locale, error);
    });
  }
  
  async loadLanguagePack(locale: string) {
    try {
      I18n.notify('translationsLoading', locale);
      
      const response = await fetch(`/api/translations/${locale}`);
      const translations = await response.json();
      
      I18n.store(translations, locale);
      I18n.notify('translationsLoaded', locale, translations);
      
    } catch (error) {
      I18n.notify('translationsError', locale, error);
    }
  }
  
  private showLoadingIndicator() {
    // Show loading UI
  }
  
  private hideLoadingIndicator() {
    // Hide loading UI
  }
  
  private showError(error: any) {
    // Show error message
  }
}
```

---

## üåç Locale Management

### **Dynamic Locale Detection**

```typescript
class LocaleDetector {
  static detectUserLocale(): string {
    // Browser language detection
    if (typeof navigator !== 'undefined') {
      const language = navigator.language || (navigator as any).userLanguage;
      return language.split('-')[0]; // Extract language code
    }
    
    // Server-side detection (Node.js)
    if (typeof process !== 'undefined') {
      return process.env.LANG?.split('.')[0]?.replace('_', '-') || 'en';
    }
    
    return 'en'; // Default fallback
  }
  
  static getSupportedLocales(): string[] {
    return Object.keys(I18n.translations);
  }
  
  static getBestMatchingLocale(preferredLocale: string): string {
    const supported = this.getSupportedLocales();
    
    // Exact match
    if (supported.includes(preferredLocale)) {
      return preferredLocale;
    }
    
    // Language family match (e.g., 'en-US' -> 'en')
    const languageCode = preferredLocale.split('-')[0];
    if (supported.includes(languageCode)) {
      return languageCode;
    }
    
    // Default fallback
    return I18n.defaultLocale || 'en';
  }
}

// Auto-detect and set locale
const detectedLocale = LocaleDetector.detectUserLocale();
const bestLocale = LocaleDetector.getBestMatchingLocale(detectedLocale);
I18n.locale = bestLocale;
```

### **Locale Storage and Persistence**

```typescript
class LocaleStorage {
  private static STORAGE_KEY = 'user-locale';
  
  static saveLocale(locale: string): void {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(this.STORAGE_KEY, locale);
    }
  }
  
  static loadLocale(): string | null {
    if (typeof localStorage !== 'undefined') {
      return localStorage.getItem(this.STORAGE_KEY);
    }
    return null;
  }
  
  static initializeLocale(): void {
    // Priority: saved locale > detected locale > default
    const savedLocale = this.loadLocale();
    const detectedLocale = LocaleDetector.detectUserLocale();
    const bestLocale = LocaleDetector.getBestMatchingLocale(
      savedLocale || detectedLocale
    );
    
    I18n.locale = bestLocale;
    
    // Save the locale
    this.saveLocale(bestLocale);
    
    // Listen for locale changes and save them
    I18n.observe('localeChanged', (newLocale) => {
      this.saveLocale(newLocale);
    });
  }
}

// Initialize locale system
LocaleStorage.initializeLocale();
```

---

## üìÖ Date and Time Localization

### **Moment.js Integration**

```typescript
class DateTimeLocalizer {
  static initializeMomentLocales() {
    // Configure moment.js with locale data
    I18n.observe('localeChanged', (newLocale) => {
      this.setMomentLocale(newLocale);
    });
    
    // Set initial locale
    this.setMomentLocale(I18n.locale);
  }
  
  private static setMomentLocale(locale: string) {
    // Load moment locale if needed
    if (typeof moment !== 'undefined') {
      moment.locale(locale);
    }
  }
  
  static formatDate(date: Date, format?: string): string {
    const defaultFormat = I18n.t('formats.date', { 
      defaultValue: 'YYYY-MM-DD' 
    });
    
    return moment(date).format(format || defaultFormat);
  }
  
  static formatDateTime(date: Date): string {
    const format = I18n.t('formats.dateTime', { 
      defaultValue: 'YYYY-MM-DD HH:mm' 
    });
    
    return moment(date).format(format);
  }
  
  static formatRelative(date: Date): string {
    return moment(date).fromNow();
  }
}

// Translation definitions for date formats
const dateTranslations = {
  en: {
    formats: {
      date: 'MM/DD/YYYY',
      dateTime: 'MM/DD/YYYY hh:mm A',
      time: 'hh:mm A'
    }
  },
  fr: {
    formats: {
      date: 'DD/MM/YYYY',
      dateTime: 'DD/MM/YYYY HH:mm',
      time: 'HH:mm'
    }
  },
  de: {
    formats: {
      date: 'DD.MM.YYYY',
      dateTime: 'DD.MM.YYYY HH:mm',
      time: 'HH:mm'
    }
  }
};

// Usage
DateTimeLocalizer.initializeMomentLocales();
const now = new Date();

I18n.locale = 'en';
console.log(DateTimeLocalizer.formatDate(now)); // "01/15/2024"

I18n.locale = 'fr';
console.log(DateTimeLocalizer.formatDate(now)); // "15/01/2024"

I18n.locale = 'de';
console.log(DateTimeLocalizer.formatDate(now)); // "15.01.2024"
```

---

## üé® UI Component Integration

### **React-like Component Integration**

```typescript
class TranslatableComponent {
  private element: HTMLElement;
  private translations: { [key: string]: string } = {};
  
  constructor(elementId: string) {
    this.element = document.getElementById(elementId)!;
    this.initializeTranslations();
    this.bindEvents();
  }
  
  private initializeTranslations() {
    // Extract translation keys from data attributes
    const elements = this.element.querySelectorAll('[data-i18n]');
    elements.forEach((el: Element) => {
      const key = el.getAttribute('data-i18n')!;
      this.translations[key] = I18n.t(key);
      el.textContent = this.translations[key];
    });
  }
  
  private bindEvents() {
    I18n.observe('localeChanged', () => {
      this.updateTranslations();
    });
  }
  
  private updateTranslations() {
    Object.keys(this.translations).forEach(key => {
      this.translations[key] = I18n.t(key);
      
      // Update DOM elements
      const elements = this.element.querySelectorAll(`[data-i18n="${key}"]`);
      elements.forEach((el: Element) => {
        el.textContent = this.translations[key];
      });
    });
  }
}

// HTML structure
/*
<div id="app">
  <h1 data-i18n="app.title">Title</h1>
  <p data-i18n="app.description">Description</p>
  <button data-i18n="buttons.submit">Submit</button>
</div>
*/

// Usage
const app = new TranslatableComponent('app');

// Language switching automatically updates all elements
I18n.locale = 'fr'; // All elements update automatically
```

### **Form Integration**

```typescript
class TranslatableForm {
  private form: HTMLFormElement;
  
  constructor(formId: string) {
    this.form = document.getElementById(formId) as HTMLFormElement;
    this.initializeFormTranslations();
    this.bindValidationMessages();
  }
  
  private initializeFormTranslations() {
    // Translate labels
    const labels = this.form.querySelectorAll('label[data-i18n]');
    labels.forEach((label: Element) => {
      const key = label.getAttribute('data-i18n')!;
      label.textContent = I18n.t(key);
    });
    
    // Translate placeholders
    const inputs = this.form.querySelectorAll('input[data-i18n-placeholder]');
    inputs.forEach((input: Element) => {
      const key = (input as HTMLInputElement).getAttribute('data-i18n-placeholder')!;
      (input as HTMLInputElement).placeholder = I18n.t(key);
    });
    
    // Translate buttons
    const buttons = this.form.querySelectorAll('button[data-i18n]');
    buttons.forEach((button: Element) => {
      const key = button.getAttribute('data-i18n')!;
      button.textContent = I18n.t(key);
    });
  }
  
  private bindValidationMessages() {
    const inputs = this.form.querySelectorAll('input, textarea, select');
    inputs.forEach((input: Element) => {
      input.addEventListener('invalid', (event) => {
        const inputElement = event.target as HTMLInputElement;
        const validationKey = this.getValidationKey(inputElement);
        const message = I18n.t(validationKey, { 
          field: this.getFieldLabel(inputElement) 
        });
        inputElement.setCustomValidity(message);
      });
      
      input.addEventListener('input', (event) => {
        (event.target as HTMLInputElement).setCustomValidity('');
      });
    });
  }
  
  private getValidationKey(input: HTMLInputElement): string {
    if (input.validity.valueMissing) return 'validation.required';
    if (input.validity.typeMismatch) return 'validation.invalidFormat';
    if (input.validity.tooShort) return 'validation.tooShort';
    if (input.validity.tooLong) return 'validation.tooLong';
    return 'validation.invalid';
  }
  
  private getFieldLabel(input: HTMLInputElement): string {
    const label = this.form.querySelector(`label[for="${input.id}"]`);
    return label?.textContent || input.name || 'field';
  }
}

// Validation translations
const validationTranslations = {
  en: {
    validation: {
      required: '%{field} is required',
      invalidFormat: '%{field} has invalid format',
      tooShort: '%{field} is too short',
      tooLong: '%{field} is too long',
      invalid: '%{field} is invalid'
    }
  },
  fr: {
    validation: {
      required: '%{field} est requis',
      invalidFormat: '%{field} a un format invalide',
      tooShort: '%{field} est trop court',
      tooLong: '%{field} est trop long',
      invalid: '%{field} est invalide'
    }
  }
};
```

---

## üöÄ Performance Optimization

### **Translation Caching**

```typescript
class TranslationCache {
  private static cache = new Map<string, string>();
  private static cacheKey(key: string, locale: string, options?: any): string {
    return `${locale}:${key}:${JSON.stringify(options || {})}`;
  }
  
  static get(key: string, locale: string, options?: any): string | undefined {
    const cacheKey = this.cacheKey(key, locale, options);
    return this.cache.get(cacheKey);
  }
  
  static set(key: string, locale: string, translation: string, options?: any): void {
    const cacheKey = this.cacheKey(key, locale, options);
    this.cache.set(cacheKey, translation);
  }
  
  static clear(): void {
    this.cache.clear();
  }
  
  static clearLocale(locale: string): void {
    const keysToDelete: string[] = [];
    this.cache.forEach((value, key) => {
      if (key.startsWith(`${locale}:`)) {
        keysToDelete.push(key);
      }
    });
    keysToDelete.forEach(key => this.cache.delete(key));
  }
}

// Enhanced I18n with caching
class CachedI18n extends I18n {
  static t(key: string, options?: any): string {
    const cached = TranslationCache.get(key, this.locale, options);
    if (cached) {
      return cached;
    }
    
    const translation = super.t(key, options);
    TranslationCache.set(key, this.locale, translation, options);
    
    return translation;
  }
}
```

### **Lazy Translation Loading**

```typescript
class LazyTranslationLoader {
  private static loadedModules = new Set<string>();
  private static loadingPromises = new Map<string, Promise<any>>();
  
  static async loadModule(module: string, locale: string): Promise<void> {
    const moduleKey = `${module}:${locale}`;
    
    if (this.loadedModules.has(moduleKey)) {
      return; // Already loaded
    }
    
    if (this.loadingPromises.has(moduleKey)) {
      return this.loadingPromises.get(moduleKey)!; // Already loading
    }
    
    const loadPromise = this.doLoadModule(module, locale);
    this.loadingPromises.set(moduleKey, loadPromise);
    
    try {
      await loadPromise;
      this.loadedModules.add(moduleKey);
    } finally {
      this.loadingPromises.delete(moduleKey);
    }
  }
  
  private static async doLoadModule(module: string, locale: string): Promise<void> {
    try {
      const response = await fetch(`/translations/${locale}/${module}.json`);
      const translations = await response.json();
      
      // Merge with existing translations
      const existingTranslations = I18n.translations[locale] || {};
      I18n.store({
        [locale]: {
          ...existingTranslations,
          [module]: translations
        }
      });
      
    } catch (error) {
      console.error(`Failed to load translation module ${module}:${locale}`, error);
    }
  }
}

// Usage
await LazyTranslationLoader.loadModule('dashboard', 'en');
await LazyTranslationLoader.loadModule('settings', 'fr');
```

---

## üéØ Best Practices

### **1. Key Organization**
```typescript
// ‚úÖ Good: Hierarchical organization
const translations = {
  en: {
    nav: {
      home: 'Home',
      about: 'About',
      contact: 'Contact'
    },
    user: {
      profile: {
        title: 'User Profile',
        edit: 'Edit Profile'
      },
      settings: {
        title: 'User Settings',
        privacy: 'Privacy Settings'
      }
    }
  }
};

// ‚ùå Avoid: Flat structure
const badTranslations = {
  en: {
    navHome: 'Home',
    navAbout: 'About',
    userProfileTitle: 'User Profile',
    userProfileEdit: 'Edit Profile'
  }
};
```

### **2. Interpolation**
```typescript
// ‚úÖ Good: Clear variable names
I18n.t('user.welcome', { userName: 'John', unreadCount: 5 });

// ‚ùå Avoid: Unclear variable names
I18n.t('user.welcome', { u: 'John', c: 5 });
```

### **3. Fallbacks**
```typescript
// ‚úÖ Good: Always provide fallbacks
I18n.t('newFeature.title', { defaultValue: 'New Feature' });

// ‚ùå Avoid: Missing translations without fallbacks
I18n.t('newFeature.title'); // May return undefined
```

---

The I18n module in @resk/core provides a comprehensive, reactive internationalization solution that scales from simple applications to complex, multi-language enterprise systems.
