"use client";
import { IHtmlDivProps } from "@html/types";
import { ObservableComponent } from "@utils/Component";
import { IFormData, IFormEvent, IFormOnSubmitOptions } from "./types";
import { Auth, IAuthPerm } from "@resk/core/auth";
import { IKeyboardEventHandlerKey } from "@components/KeyboardEventHandler/keyEvents";
import { IField, IFields } from "@resk/core/types";
import { Fragment, isValidElement, ReactElement, ReactNode, useCallback, useEffect, useId, useMemo, useRef } from "react";
import { IClassName } from "@src/types";
import { defaultStr, extendObj, isEmpty, isObj, typedEntries } from "@resk/core/utils";
import useStateCallback from "@utils/stateCallback";
import { IObservable, observableFactory } from "@resk/core/observable";
import stableHash from 'stable-hash';
import { IKeyboardEventHandlerEvent } from "@components/KeyboardEventHandler";

export class FormClass extends ObservableComponent<IFormProps, IFormState, IFormEvent> {
    private _hasTriedTobeSubmitted?: boolean = false;
    private validationStatus = false;
    private readonly fields: IFormFields = {};
    private errors: string[] = [];


    renderChildren(options: IFormProps): ReactElement {
        const children =
            typeof options?.children == "function" ? options.children(options) : options?.children;
        if (children && this.isLoading(options)) return this.renderLoading(options);
        return isValidElement(children) ? (children as ReactElement) : <Fragment />;
    }

    getForm(name: string): Form | undefined {
        return FormsManager.getForm(name) as any;
    }
    getField(fieldName: string): IFormField | null {
        if (!isNonNullString(fieldName)) return null;
        return this.getFields()[fieldName] || null;
    }
    isValid(): boolean {
        const fields = this.getFields();
        this.errors = [];
        for (let j in fields) {
            const f = fields[j];
            if (f && !f.isValid()) {
                this.errors.push(`[${f.getLabel()}] : ${f.getErrorText()}`);
            }
        }
        if (this.errors.length) {
            return false;
        }
        return true;
    }
    unmountField(field: IFormField) {
        if (!field) return;
        delete this.fields[field.getName()];
    }
    isResource() {
        return false;
    }
    setHasTriedTobeSubmitted(hasTriedTobeSubmitted: boolean) {
        this._hasTriedTobeSubmitted = hasTriedTobeSubmitted;
    }
    hasTriedTobeSubmitted() {
        return !!this._hasTriedTobeSubmitted;
    }
    getActions(): Record<string, IFormAction> {
        return FormsManager.getActions(this.getName());
    }
    resetFields() {
        const fields = this.getFields();
        for (let i in fields) {
            delete fields[i];
        }
    }

    toggleActionIsLoading(actionIsLoading: boolean): void {
        const actions = this.getActions();
        for (let i in actions) {
            const action = actions[i];
            if (isObj(action) && action && typeof (action as any).setIsLoading === "function") {
                (action as any).setIsLoading(actionIsLoading);
            }
        }
    }

    /***
     * met à jour les status des actions associés au composant FormBase
     * @param {boolean} validationStatus, le nouveau status du formulaire, à appliquer à toutes les actions associées à la form
     *      - si validationStatus n'est pas passé en paramètre alors \n
     *          - si tous les champs sont valides, toutes les actions seront activés et \n
     *          - si un seul des champ est invalide, toutes les actions seront désactivées
    @return {boolean} retourne le nouveau status pris par les actions du formulaire. 
    */
    toggleValidationStatus(validationStatus?: boolean, trigger?: boolean): boolean {
        if (!this.hasTriedTobeSubmitted()) return validationStatus as boolean;
        const actions = this.getActions();
        validationStatus = typeof validationStatus !== "boolean" ? this.isValid() : validationStatus;
        for (var k in actions) {
            const action = actions[k];
            if (action) {
                if (validationStatus) {
                    if (typeof (action as any)?.enable === "function") {
                        (action as any).enable();
                    }
                } else if (typeof (action as any)?.disable === "function") {
                    (action as any).disable();
                }
            }
        }
        if (validationStatus !== this.validationStatus || trigger === true) {
            FormsManager.trigger("formValidationStatusChanged", {
                formName: this.getName(),
                isValild: this.isValid(),
                form: this,
            });
            this.validationStatus = validationStatus;
        }
        this.validationStatus = !!this.validationStatus;
        return validationStatus;
    }
    static Loading: FC<IFormProps> = (props) => {
        return (
            <View
                testID={`${props?.testID || ""}-form-loading-container`}
                style={styles.loadingContainer}
            >
                <ActivityIndicator size={"large"} />
            </View>
        );
    }

    static Fields: FC<IFormProps & IFormContext> = (props) => {
        const theme = useTheme();
        const { fields, data, name: formName, testID: cTestID, form, windowWidth, isLoading, isSubmitting } = props;
        const testID = defaultStr(cTestID, "resk-form");
        const { drawer } = useDrawer();
        return useMemo(() => {
            if (!Object.getSize(fields, true)) return null;
            const content: ReactNode[] = [];
            for (let i in fields) {
                const field = fields[i];
                if (!isObj(field)) continue;
                const name = defaultStr(field?.name, i);
                const type = field?.type || "text" as IFieldType;
                let defaultValue = undefined;
                if (isObj(data)) {
                    if (!isEmpty((data as any)[name])) {
                        defaultValue = (data as any)[name];
                    }
                }
                if (isEmpty(defaultValue) && !isEmpty(field?.defaultValue)) {
                    defaultValue = field?.defaultValue;
                } else {
                }
                const fieldProps = {
                    testID: `${testID}-field-${name}`,
                    ...field,
                    name,
                    type,
                    formName,
                    data,
                };
                if (isSubmitting) {
                    fieldProps.readOnly = true;
                }
                if (!isEmpty(defaultValue)) {
                    fieldProps.defaultValue = defaultValue;
                } else if (isObj(data) && name in (data as any)) {
                    fieldProps.defaultValue = (data as any)[name];
                }
                const drawerWidth = drawer?.isProvider() && drawer?.getDrawerWidth() || undefined;
                fieldProps.windowWidth = fieldProps.windowWidth || windowWidth || typeof drawerWidth === "number" && drawerWidth || undefined
                const Component = Field.getRegisteredComponent(type as IFieldType) || Field.getRegisteredComponent("text") || Field as any;
                content.push(<Component {...fieldProps} isFormLoading={isLoading} isFormSubmitting={isSubmitting} key={name} />);
            }
            return content;
        }, [theme, formName, props.isUpdate, data, fields, isLoading, isSubmitting]) as ReactNode[];
    }
    /**
     * A provider class for managing dialog interactions with forms. This class extends a base provider
     * and provides static methods to open and close form dialogs. It integrates with the `DialogControlled`
     * component and dynamically renders a `Form` component within the dialog.
     *
     * @template IFormDialogProps - The interface defining the properties for the form dialog.
     * @template DialogControlled - The base dialog component to be controlled by this provider.
     */
    static Dialog = FormDialogProvider;

    /**
     * A specialized provider class for managing the lifecycle of a form drawer component.
     * This class extends a generic provider and integrates with a `Drawer` component to
     * handle opening and closing of a form drawer with specific properties and behaviors.
     *
     * @template IFormDrawerProps - The interface defining the properties for the form drawer.
     * @template Drawer - The drawer component to be used as the base for this provider.
     */
    static Drawer = FormDrawerProvider;

    render() {
        const props = this.props;
        const { formFields, tabs, children: cChildren, header } = this.state;
        const {
            data,
            responsive,
            style,
            tabsProps: tProps,
            mainTabItemProps,
            sessionName,
            withScrollView,
            scrollViewProps,
            ...viewProps
        } = this.props;
        const testID = viewProps.testID || "resk-form";;
        const isSubmitting = this.isSubmitting() || props?.isSubmitting;
        const tabsProps = Object.assign({}, tProps);
        const { items: tabItems, mobile } = tabs;
        const submitStyle = isSubmitting ? [isSubmitting ? styles.submitting : undefined] : [];
        const disabledStyle = isSubmitting ? Theme.styles.disabled : undefined;
        const formContainerStyle = [styles.formContainer, ...submitStyle, disabledStyle];
        const mainFormTabStyle: IViewStyle = [
            ...formContainerStyle,
            styles.mainFormTab,
            { flexDirection: responsive === false ? "column" : "row" },
        ];
        let children = (<>
            {header}
            {formFields}
            {cChildren}
        </>);
        let tabChildren = null;
        if (tabItems.length) {
            if (mobile) {
                tabItems.unshift(
                    <Tab.Item
                        label={"Principal"}
                        {...mainTabItemProps}
                        key={"principal-main-tab-item"}
                        disabled={isSubmitting}
                        children={
                            <View testID={testID + "-main-form-tab"} style={mainFormTabStyle}>
                                {children}
                            </View>
                        }
                    />
                );
            } else {
                children = (
                    <View testID={testID + "-main-form-tab-desktop"} style={mainFormTabStyle}>
                        {children}
                    </View>
                );
            }
            tabChildren = (
                <Tab
                    sessionName={sessionName}
                    {...tabsProps}
                    disabled={tabsProps.disabled || isSubmitting}
                    style={[tabsProps.style, submitStyle]}
                >
                    {tabItems}
                </Tab>
            );
        }
        const Wrapper = withScrollView ? ScrollView : Fragment;
        const wrapperProps = withScrollView ? Object.assign({}, { testID: testID + "-scrollview" }, scrollViewProps) : {};
        return (
            <FormContext.Provider value={{ form: this }}>
                <Wrapper {...wrapperProps}>
                    <View
                        {...viewProps}
                        testID={testID}
                        style={[
                            tabItems.length ? styles.tabsContainer : styles.formContainer,
                            responsive !== false && styles.responsiveFormContainer,
                            style,
                            submitStyle,
                        ]}
                    >
                        {mobile && tabItems.length ? (
                            tabChildren
                        ) : (
                            <>
                                {children}
                                {tabChildren}
                            </>
                        )}
                    </View>
                </Wrapper>
            </FormContext.Provider>
        );
    }
    static readonly Field = Field;
}










